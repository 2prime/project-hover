（一）是非判断题（正确：√，错误：×，毎题2分，共20分）

1、数据的运算是定义在逻辑结构上的，而其具体实现依赖于存储结构。（√）

2、从逻辑上考虑，静态链表属于链接结构，因此其结点空间仍然需要动态分配。（×）

3、栈和队列都是操作受限的线性表，因此其插入和删除操作效率低。（×）

4、包含n个字符的顺序串，占用n + 1个字节，因此其字符串的长度为n + 1。（×）

5、深度优先搜索算法需要栈控制，广度优先搜索算法需要队列控制。（√）

6、二叉树（包含n个顶点）的二叉链表存储结构中，必定包含n + 1个空指针。线索链表利用这些空指针保存前驱和后继信息，因此在线索链表中不再存在空指针。（×）

7、n个结点的二叉树中，终端结点数目为m，则度为1的结点数必定有n - 2 m + 1个。（√）

8、从逻辑上看，散列表属于线性结构，其碰撞处理方法主要包括开地址法和拉链法。（题目有问题，对错都给分）

9、二叉排序树中新插入的结点一定是终端结点，其形态是AVL树时，检索效率高。（√）

10、由于堆序列中的记录采用顺序表存储，因此其插入、删除仍然需要记录移动。（×）

（二）选择题（单选，毎题2分，共20分）

1、{i = 0; s = 0; while (s < n) {s = s + i; i++;}}程序段的时间复杂度为：（A）
（A）O(n^(1/2))
（B）O(n^(1/3))
（C）O(n)
（D）O(n^2)

2、设某链表中最常用的操作是在链表的尾部插入或删除元素，则下列哪种存储方式最节省运算时间：（D）
（A）单向链表
（B）单向循环链表
（C）双向链表
（D）双向循环链表

3、循环队列A[0 ... m]的头尾指针分别是F、R，牺牲一个空间区分空满时，判满条件是：（B）
（A）R + 1 == F
（B）(R + 1) % (m + 1) == F
（C）F + 1 == R
（D）(F + 1) % (m + 1) == R

4、目标串长是n，模式串长是m，经典模式匹配算法匹配成功的最多比较次数是：（D）
（A）m * n
（B）m * (n - m)
（C）m * (n - m - 1)
（D）m * (n - m + 1)

5、设某Huffman树上有199个结点，则其终端结点数目为：（B）
（A）99
（B）100
（C）101
（D）102

6、设有n个关键字具有相同的hash函数值，用线性探测法把这n个关键字存储到hash表中需要做多少次线性探测：（D）
（A）n^2
（B）n * (n + 1)
（C）n * (n + 1) / 2
（D）n * (n - 1) / 2

7、在包含n个结点的折半检索二叉判定树中，插入一个记录的时间复杂度为：（C）
（A）O(1)
（B）O(n)
（C）O(log_2 n)
（D）O(n^2)

8、十万个元素进行排序，在“稳定”需求前提下，下列排序方法应该选择：（C）
（A）起泡排序
（B）快速排序
（C）二路归并排序
（D）堆排序

9、图的下列哪种运算不能用于检测连通性问题：（D）
（A）图的遍历
（B）最短路径
（C）最小生成树
（D）拓扑排序

10、在AOE网中，下列哪种说法是错误的：（B）
（A）增加关键活动时间将延长整个工程进度
（B）增加非关键活动时间对加快整个工程进度无影响
（C）缩短关键活动时间可能加快整个工程进度
（D）缩短非关键活动时间对加快整个工程进度无影响

（三）填空题（无特别说明：每空2分，共40分）

1、设一棵m叉树中有N_1个度数为1的结点，N_2个度数为2的结点，……，N_m个度数为m的结点，则该m叉树中共有_1 + Σ_{i = 2}^m (i - 1) N_i_个终端结点。

2、一棵具有n个结点的全满k叉树具有如下性质：最后一层上的结点都是叶子结点，其余各层上的每个结点都有k个子结点，如对树中的结点按照从上到下、从左往右的次序逐层给结点编号（起始编号为）1，则有
1）第i (i >= 1)层上结点数目为_k^(i - 1)_
2）对于编号为m的结点，
父结点的编号为_(m - 2) / k + 1_，
第i (i >= 1)个孩子的编号为_(m - 1) * k + i + 1_，
有右兄弟的条件是_(m - 1) % k != 0_。

3、给出一组关键字T = (12, 2, 16, 30, 8, 28, 4, 10, 20, 6, 18)，写出用下列算法从小到大排序时第一趟结束时的序列：
1）希尔排序（起始增量为5）：_12, 2, 10, 20, 6, 18, 4, 16, 30, 8, 28_
2）快速排序（第1个记录为基准）：_6, 2, 10, 4, 8, 12, 28, 30, 20, 16, 18_
3）小根堆排序：_4, 6, 16, 10, 8, 28, 18, 30, 20, 12, 2_
4）基数排序（基数为10）：_30, 10, 20, 12, 2, 4, 16, 6, 8, 28, 18_

4、AOV网的邻接表（出边表）存储结构如下：
0 C0->2->7^
0 C1->2->3->4^
2 C2->3^
2 C3->5->6^
1 C4->5^
2 C5^
2 C6^
1 C7->8^
1 C8->6^
1）按照深度优先遍历算法，写出从C0开始的深度优先遍历结果：_C0 C2 C3 C5 C6 C7 C8 C1 C4_
2）按照广度优先遍历算法，写出从C1开始的广度优先遍历结果：_C1 C2 C3 C4 C5 C6 C0 C7 C8_
3）按照拓扑排序算法，写出AOV网的拓扑序列：_C1 C4 C0 C7 C8 C2 C3 C6 C5_

5、阅读下列算法，回答后面的问题。
LinkList function1(LinkList L)  // L是不带头结点的单链表的头指针
{
    LinkList p, q;
    if (L && L->next)
    {
        q = L;
        L = L->next;
        p = L;
        while (p->next) p = p->next;
        p->next = q;
        q->next = NULL;
    }
    return L;
}
该算法的功能为：_原第一个结点成为最后一个结点，原第二个结点成为第一个_

6、下列算法中，“<->”为交换运算，key是记录（类型为record）的关键码。
void function2(record A[], int n)
{
    int c, i = 0, j = n - 1;
    while (i < j)
    {
        while ((A[i].key % 2 == 1) && (i < j)) i++;
        while ((A[j].key % 2 == 0) && (i < j)) j--;
        if (i < j)
        {
            A[i] <-> A[j];
            i++;
            j--;
        }
    }
}
该算法的功能为：_将所有关键码为奇数的记录移到前面_

7、完成下列沿着找后继的策略进行中根线索二叉树遍历的算法。（每空1分，共4分）
struct
{
    DataType info;               // 结点数据
    ThrTreeNode *llink, *rlink;  // 左右指针
    int ltag, rtag;              // 线索标记
} ThrTreeNode;

void InOrder(ThrTreeNode* t)  // t指向根
{
    ThrTreeNode* p = t;
    if (t == NULL) return;
    while (p->llink && !p->ltag) p = _p->llink_;
    while (p)
    {
        visit(p);  // 访问结点的函数
        if (p->rlink && !p->rtag)
        {
            p = _p->rlink_;
            while (p->llink && !p->ltag) p = _p->llink_;
        }
        else
            p = _p->rlink_;
    }
}

8、完成下面在二叉排序树b中删除一个数据为x的结点的函数。（每空1分，共8分）
删除方法：如果被删结点有左子树，采用被删结点的左子树的根代替被删结点。
二叉排序树采用下列二叉链表存储：
typedef struct bnode  // data是数据项，left和right分别是指向左右孩子的指针
{
    int data;
    struct bnode *left, *right;
} btree;

btree* del_node(btree* b, int x)  // 函数返回删除后的根结点
{
    btree *p, *q, *r, *t = b;
    p = b;
    q = NULL;  // q指向p的父结点
    while (p != NULL && p->data != x)
    {
        q = p;
        if (x >= p->data)
            p = _p->right_;
        else
            p = _p->left_;
    }
    if (p == NULL)
        printf("%d not found\n", x);
    else if (p->left != NULL)
    {
        r = p->left;
        while (r->right != NULL) r = _r->right_;
        r->right = _p->right_;
        if (q == NULL)
            t = p->left;
        else if (q->left != p)
            q->right = _p->left_;
        else
            q->left = _p->left_;
    }
    else
    {
        if (q == NULL)
            t = p->right;
        else if (q->left != p)
            q->right = _p->right_;
        else
            q->left = _p->right_;
    }
    return t;
}

（四）简答题（共20分）

1、试简要比较线性表的顺序和链接存储结构的优缺点。（本题4分）
（1）插入删除：记录移动/指针修改
（2）扩展性：静态，不易/动态，容易
（3）存储密度：高/低
（4）随机性：随机存取/非随机

2、KMP无回溯模式匹配算法：（本题6分）
1）已知next数组前提下，对于串长为n的目标串，为什么算法的时间复杂度是O(n)？
i++最多m次，k++最多n次。k = next[k]使得k减少，由于k不小于-1，k = next[k]的执行次数最多n次。综合上述，算法的时间复杂度是O(n)。
2）写出模式串"abcabbc"的next数组，并分析目标串"aabcbabcabbcabca"模式匹配过程中的总比较次数（不含next数组计算）。
next数组：-1, 0, 0, -1, 0, 2, 0
比较次数：13

3、仔细阅读下列程序（算法），然后回答后续问题。（本题10分）
void SIFT(int* pData, int i, int n)
{
    int child = 2 * i + 1, temp = pData[i];
    while (child < n)
    {
        if (child < n - 1 && pData[child] < pData[child + 1]) child++;
        if (temp < pData[child])
        {
            pData[i] = pData[child];
            i = child;
            child = 2 * i + 1;
        }
        else
            break;
    }
    pData[i] = temp;
}

void function3(int* pData, int n, int k)  // “<->”为交换运算
{
    int i;
    if (k > n) return;
    for (i = k / 2 - 1; i >= 0; i--) SIFT(pData, i, k);
    for (i = k; i < n; i++)
    {
        if (pData[i] < pData[0])
        {
            pData[0] <-> pData[i];
            SIFT(pData, 0, k);
        }
    }
    for (i = k - 1; i > 0; i--)
    {
        printf("%d ", pData[0]);
        pData[0] <-> pData[i];
        SIFT(pData, 0, i);
    }
}
1）函数function3的功能？（4分，可用简单例子描述）
从n个数中选择最小的k个数，并对k个最小数按照从大到小输出。
2）给定问题规模n和k值（k << n），分析算法function3的时间复杂度。（6分，简单过程和O表示）
前面k个数的初始堆构建：O(k)
后面n - k个数与前面k个数的最大者比较，小于则替换，否则不处理：O(n + n log_2 k)
k最小数的堆排序（不含初始堆构建）：O(k log_2 k)
考虑k << n，总的：O(k + n + n log_2 k + k log_2 k) = O(n + n log_2 k)
